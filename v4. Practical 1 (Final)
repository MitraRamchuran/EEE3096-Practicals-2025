/* USER CODE BEGIN Header */ 

/** 

****************************************************************************** 

* @file : main.c 

* @brief : Main program body 

****************************************************************************** 

* @attention 

* 

* Copyright (c) 2023 STMicroelectronics. 

* All rights reserved. 

* 

* This software is licensed under terms that can be found in the LICENSE file 

* in the root directory of this software component. 

* If no LICENSE file comes with this software, it is provided AS-IS. 

* 

****************************************************************************** 

*/ 

/* USER CODE END Header */ 

/* Includes ------------------------------------------------------------------*/ 

#include "main.h" 

 

/* Private includes ----------------------------------------------------------*/ 

/* USER CODE BEGIN Includes */ 

#include <stdint.h> 

#include "stm32f0xx.h" 

/* USER CODE END Includes */ 

 

/* Private typedef -----------------------------------------------------------*/ 

/* USER CODE BEGIN PTD */ 

 

/* USER CODE END PTD */ 

 

/* Private define ------------------------------------------------------------*/ 

/* USER CODE BEGIN PD */ 

 

/* USER CODE END PD */ 

 

/* Private macro -------------------------------------------------------------*/ 

/* USER CODE BEGIN PM */ 

 

/* USER CODE END PM */ 

 

/* Private variables ---------------------------------------------------------*/ 

TIM_HandleTypeDef htim16; 

 

/* USER CODE BEGIN PV */ 

// Define input variables 

uint8_t currentMode = 0; // 0: off, 1: mode1, 2: mode2, 3: mode3 

uint8_t currentLED = 0; // Current LED position for mode1 and mode2 

uint8_t direction = 1; // 1: forward, 0: backward for mode1 and mode2 

uint8_t delayMode = 0; // 0: 1s delay, 1: 0.5s delay 

uint8_t sparkleCounter = 0; 

uint8_t sparkleDelay = 0; 

/* USER CODE END PV */ 

 

/* Private function prototypes -----------------------------------------------*/ 

void SystemClock_Config(void); 

static void MX_GPIO_Init(void); 

static void MX_TIM16_Init(void); 

/* USER CODE BEGIN PFP */ 

void TIM16_IRQHandler(void); 

/* USER CODE END PFP */ 

 

/* Private user code ---------------------------------------------------------*/ 

/* USER CODE BEGIN 0 */ 

 

/* USER CODE END 0 */ 

 

/** 

* @brief The application entry point. 

* @retval int 

*/ 

int main(void) 

{ 

/* USER CODE BEGIN 1 */ 

/* USER CODE END 1 */ 

 

/* MCU Configuration--------------------------------------------------------*/ 

 

/* Reset of all peripherals, Initializes the Flash interface and the Systick. */ 

HAL_Init(); 

 

/* USER CODE BEGIN Init */ 

/* USER CODE END Init */ 

 

/* Configure the system clock */ 

SystemClock_Config(); 

 

/* USER CODE BEGIN SysInit */ 

/* USER CODE END SysInit */ 

 

/* Initialize all configured peripherals */ 

MX_GPIO_Init(); 

MX_TIM16_Init(); 

/* USER CODE BEGIN 2 */ 

 

// Start timer TIM16 

HAL_TIM_Base_Start_IT(&htim16); 

 

/* USER CODE END 2 */ 

 

/* Infinite loop */ 

/* USER CODE BEGIN WHILE */ 

while (1) 

{ 

/* USER CODE END WHILE */ 

 

/* USER CODE BEGIN 3 */ 

 

// Check pushbuttons to change timer delay 

 // Check pushbuttons to change timer delay 

 if (LL_GPIO_IsInputPinSet(Button0_GPIO_Port, Button0_Pin) == 0) { 

 HAL_Delay(50); // Simple debounce 

 if (LL_GPIO_IsInputPinSet(Button0_GPIO_Port, Button0_Pin) == 0) { 

 

 // Cycle delayMode: 0 -> 1 -> 2 -> 0 ... 

 // 0 = 1s, 1 = 2s, 2 = 0.5s 

 delayMode = (delayMode + 1) % 3; 

 

 if (delayMode == 0) { 

 __HAL_TIM_SET_AUTORELOAD(&htim16, 1000 - 1); // 1s delay 

 } 

 else if (delayMode == 1) { 

 __HAL_TIM_SET_AUTORELOAD(&htim16, 2000 - 1); // 2s delay 

 } 

 else if (delayMode == 2) { 

 __HAL_TIM_SET_AUTORELOAD(&htim16, 500 - 1); // 0.5s delay 

 } 

 

 __HAL_TIM_SET_COUNTER(&htim16, 0); // Reset counter 

 } 

 while (LL_GPIO_IsInputPinSet(Button0_GPIO_Port, Button0_Pin) == 0); // Wait for release 

 } 

 

// Check other buttons for mode changes 

if (LL_GPIO_IsInputPinSet(Button1_GPIO_Port, Button1_Pin) == 0) { 

HAL_Delay(50); 

if (LL_GPIO_IsInputPinSet(Button1_GPIO_Port, Button1_Pin) == 0) { 

currentMode = 1; 

currentLED = 0; 

direction = 1; 

} 

while (LL_GPIO_IsInputPinSet(Button1_GPIO_Port, Button1_Pin) == 0); 

} 

 

if (LL_GPIO_IsInputPinSet(Button2_GPIO_Port, Button2_Pin) == 0) { 

HAL_Delay(50); 

if (LL_GPIO_IsInputPinSet(Button2_GPIO_Port, Button2_Pin) == 0) { 

currentMode = 2; 

currentLED = 0; 

direction = 1; 

} 

while (LL_GPIO_IsInputPinSet(Button2_GPIO_Port, Button2_Pin) == 0); 

} 

 

if (LL_GPIO_IsInputPinSet(Button3_GPIO_Port, Button3_Pin) == 0) { 

HAL_Delay(50); 

if (LL_GPIO_IsInputPinSet(Button3_GPIO_Port, Button3_Pin) == 0) { 

currentMode = 3; 

sparkleCounter = 0; 

sparkleDelay = (HAL_GetTick() % 14) + 1; 

} 

while (LL_GPIO_IsInputPinSet(Button3_GPIO_Port, Button3_Pin) == 0); 

} 

} 

/* USER CODE END 3 */ 

} 

 

/** 

* @brief System Clock Configuration 

* @retval None 

*/ 

void SystemClock_Config(void) 

{ 

LL_FLASH_SetLatency(LL_FLASH_LATENCY_0); 

while(LL_FLASH_GetLatency() != LL_FLASH_LATENCY_0) 

{ 

} 

LL_RCC_HSI_Enable(); 

 

/* Wait till HSI is ready */ 

while(LL_RCC_HSI_IsReady() != 1) 

{ 

 

} 

LL_RCC_HSI_SetCalibTrimming(16); 

LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_1); 

LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_1); 

LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_HSI); 

 

/* Wait till System clock is ready */ 

while(LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_HSI) 

{ 

 

} 

LL_SetSystemCoreClock(8000000); 

 

/* Update the time base */ 

if (HAL_InitTick (TICK_INT_PRIORITY) != HAL_OK) 

{ 

Error_Handler(); 

} 

} 

 

/** 

* @brief TIM16 Initialization Function 

* @param None 

* @retval None 

*/ 

static void MX_TIM16_Init(void) 

{ 

 

/* USER CODE BEGIN TIM16_Init 0 */ 

 

/* USER CODE END TIM16_Init 0 */ 

 

/* USER CODE BEGIN TIM16_Init 1 */ 

 

/* USER CODE END TIM16_Init 1 */ 

htim16.Instance = TIM16; 

htim16.Init.Prescaler = 8000-1; 

htim16.Init.CounterMode = TIM_COUNTERMODE_UP; 

htim16.Init.Period = 1000-1; 

htim16.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1; 

htim16.Init.RepetitionCounter = 0; 

htim16.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE; 

if (HAL_TIM_Base_Init(&htim16) != HAL_OK) 

{ 

Error_Handler(); 

} 

/* USER CODE BEGIN TIM16_Init 2 */ 

NVIC_EnableIRQ(TIM16_IRQn); 

/* USER CODE END TIM16_Init 2 */ 

 

} 

 

/** 

* @brief GPIO Initialization Function 

* @param None 

* @retval None 

*/ 

static void MX_GPIO_Init(void) 

{ 

LL_GPIO_InitTypeDef GPIO_InitStruct = {0}; 

/* USER CODE BEGIN MX_GPIO_Init_1 */ 

/* USER CODE END MX_GPIO_Init_1 */ 

 

/* GPIO Ports Clock Enable */ 

LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOF); 

LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOA); 

LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOB); 

 

// 

LL_GPIO_ResetOutputPin(LED0_GPIO_Port, LED0_Pin); 

 

// 

LL_GPIO_ResetOutputPin(LED1_GPIO_Port, LED1_Pin); 

 

// 

LL_GPIO_ResetOutputPin(LED2_GPIO_Port, LED2_Pin); 

 

// 

LL_GPIO_ResetOutputPin(LED3_GPIO_Port, LED3_Pin); 

 

// 

LL_GPIO_ResetOutputPin(LED4_GPIO_Port, LED4_Pin); 

 

// 

LL_GPIO_ResetOutputPin(LED5_GPIO_Port, LED5_Pin); 

 

// 

LL_GPIO_ResetOutputPin(LED6_GPIO_Port, LED6_Pin); 

 

// 

LL_GPIO_ResetOutputPin(LED7_GPIO_Port, LED7_Pin); 

 

// 

GPIO_InitStruct.Pin = Button0_Pin; 

GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT; 

GPIO_InitStruct.Pull = LL_GPIO_PULL_UP; 

LL_GPIO_Init(Button0_GPIO_Port, &GPIO_InitStruct); 

 

// 

GPIO_InitStruct.Pin = Button1_Pin; 

GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT; 

GPIO_InitStruct.Pull = LL_GPIO_PULL_UP; 

LL_GPIO_Init(Button1_GPIO_Port, &GPIO_InitStruct); 

 

// 

GPIO_InitStruct.Pin = Button2_Pin; 

GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT; 

GPIO_InitStruct.Pull = LL_GPIO_PULL_UP; 

LL_GPIO_Init(Button2_GPIO_Port, &GPIO_InitStruct); 

 

// 

GPIO_InitStruct.Pin = Button3_Pin; 

GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT; 

GPIO_InitStruct.Pull = LL_GPIO_PULL_UP; 

LL_GPIO_Init(Button3_GPIO_Port, &GPIO_InitStruct); 

 

// 

GPIO_InitStruct.Pin = LED0_Pin; 

GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT; 

GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW; 

GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL; 

GPIO_InitStruct.Pull = LL_GPIO_PULL_NO; 

LL_GPIO_Init(LED0_GPIO_Port, &GPIO_InitStruct); 

 

// 

GPIO_InitStruct.Pin = LED1_Pin; 

GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT; 

GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW; 

GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL; 

GPIO_InitStruct.Pull = LL_GPIO_PULL_NO; 

LL_GPIO_Init(LED1_GPIO_Port, &GPIO_InitStruct); 

 

// 

GPIO_InitStruct.Pin = LED2_Pin; 

GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT; 

GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW; 

GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL; 

GPIO_InitStruct.Pull = LL_GPIO_PULL_NO; 

LL_GPIO_Init(LED2_GPIO_Port, &GPIO_InitStruct); 

 

// 

GPIO_InitStruct.Pin = LED3_Pin; 

GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT; 

GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW; 

GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL; 

GPIO_InitStruct.Pull = LL_GPIO_PULL_NO; 

LL_GPIO_Init(LED3_GPIO_Port, &GPIO_InitStruct); 

 

// 

GPIO_InitStruct.Pin = LED4_Pin; 

GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT; 

GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW; 

GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL; 

GPIO_InitStruct.Pull = LL_GPIO_PULL_NO; 

LL_GPIO_Init(LED4_GPIO_Port, &GPIO_InitStruct); 

 

// 

GPIO_InitStruct.Pin = LED5_Pin; 

GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT; 

GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW; 

GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL; 

GPIO_InitStruct.Pull = LL_GPIO_PULL_NO; 

LL_GPIO_Init(LED5_GPIO_Port, &GPIO_InitStruct); 

 

// 

GPIO_InitStruct.Pin = LED6_Pin; 

GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT; 

GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW; 

GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL; 

GPIO_InitStruct.Pull = LL_GPIO_PULL_NO; 

LL_GPIO_Init(LED6_GPIO_Port, &GPIO_InitStruct); 

 

// 

GPIO_InitStruct.Pin = LED7_Pin; 

GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT; 

GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW; 

GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL; 

GPIO_InitStruct.Pull = LL_GPIO_PULL_NO; 

LL_GPIO_Init(LED7_GPIO_Port, &GPIO_InitStruct); 

 

/* USER CODE BEGIN MX_GPIO_Init_2 */ 

/* USER CODE END MX_GPIO_Init_2 */ 

} 

 

/* USER CODE BEGIN 4 */ 

void TIM16_IRQHandler(void) 

{ 

// Acknowledge interrupt 

HAL_TIM_IRQHandler(&htim16); 

 

// Change LED pattern 

switch(currentMode) { 

case 0: // All LEDs off 

LL_GPIO_ResetOutputPin(LED0_GPIO_Port, LED0_Pin); 

LL_GPIO_ResetOutputPin(LED1_GPIO_Port, LED1_Pin); 

LL_GPIO_ResetOutputPin(LED2_GPIO_Port, LED2_Pin); 

LL_GPIO_ResetOutputPin(LED3_GPIO_Port, LED3_Pin); 

LL_GPIO_ResetOutputPin(LED4_GPIO_Port, LED4_Pin); 

LL_GPIO_ResetOutputPin(LED5_GPIO_Port, LED5_Pin); 

LL_GPIO_ResetOutputPin(LED6_GPIO_Port, LED6_Pin); 

LL_GPIO_ResetOutputPin(LED7_GPIO_Port, LED7_Pin); 

break; 

 

case 1: // Mode 1: Single LED back and forth 

// Turn off all LEDs first 

LL_GPIO_ResetOutputPin(LED0_GPIO_Port, LED0_Pin); 

LL_GPIO_ResetOutputPin(LED1_GPIO_Port, LED1_Pin); 

LL_GPIO_ResetOutputPin(LED2_GPIO_Port, LED2_Pin); 

LL_GPIO_ResetOutputPin(LED3_GPIO_Port, LED3_Pin); 

LL_GPIO_ResetOutputPin(LED4_GPIO_Port, LED4_Pin); 

LL_GPIO_ResetOutputPin(LED5_GPIO_Port, LED5_Pin); 

LL_GPIO_ResetOutputPin(LED6_GPIO_Port, LED6_Pin); 

LL_GPIO_ResetOutputPin(LED7_GPIO_Port, LED7_Pin); 

 

// Turn on current LED 

switch(currentLED) { 

case 0: LL_GPIO_SetOutputPin(LED0_GPIO_Port, LED0_Pin); break; 

case 1: LL_GPIO_SetOutputPin(LED1_GPIO_Port, LED1_Pin); break; 

case 2: LL_GPIO_SetOutputPin(LED2_GPIO_Port, LED2_Pin); break; 

case 3: LL_GPIO_SetOutputPin(LED3_GPIO_Port, LED3_Pin); break; 

case 4: LL_GPIO_SetOutputPin(LED4_GPIO_Port, LED4_Pin); break; 

case 5: LL_GPIO_SetOutputPin(LED5_GPIO_Port, LED5_Pin); break; 

case 6: LL_GPIO_SetOutputPin(LED6_GPIO_Port, LED6_Pin); break; 

case 7: LL_GPIO_SetOutputPin(LED7_GPIO_Port, LED7_Pin); break; 

} 

 

// Update position 

if (direction) { 

if (currentLED == 7) { 

direction = 0; 

currentLED = 6; // Skip the same LED 

} else { 

currentLED++; 

} 

} else { 

if (currentLED == 0) { 

direction = 1; 

currentLED = 1; // Skip the same LED 

} else { 

currentLED--; 

} 

} 

break; 

 

case 2: // Mode 2: Inverse of mode 1 

// Turn on all LEDs first 

LL_GPIO_SetOutputPin(LED0_GPIO_Port, LED0_Pin); 

LL_GPIO_SetOutputPin(LED1_GPIO_Port, LED1_Pin); 

LL_GPIO_SetOutputPin(LED2_GPIO_Port, LED2_Pin); 

LL_GPIO_SetOutputPin(LED3_GPIO_Port, LED3_Pin); 

LL_GPIO_SetOutputPin(LED4_GPIO_Port, LED4_Pin); 

LL_GPIO_SetOutputPin(LED5_GPIO_Port, LED5_Pin); 

LL_GPIO_SetOutputPin(LED6_GPIO_Port, LED6_Pin); 

LL_GPIO_SetOutputPin(LED7_GPIO_Port, LED7_Pin); 

 

// Turn off current LED 

switch(currentLED) { 

case 0: LL_GPIO_ResetOutputPin(LED0_GPIO_Port, LED0_Pin); break; 

case 1: LL_GPIO_ResetOutputPin(LED1_GPIO_Port, LED1_Pin); break; 

case 2: LL_GPIO_ResetOutputPin(LED2_GPIO_Port, LED2_Pin); break; 

case 3: LL_GPIO_ResetOutputPin(LED3_GPIO_Port, LED3_Pin); break; 

case 4: LL_GPIO_ResetOutputPin(LED4_GPIO_Port, LED4_Pin); break; 

case 5: LL_GPIO_ResetOutputPin(LED5_GPIO_Port, LED5_Pin); break; 

case 6: LL_GPIO_ResetOutputPin(LED6_GPIO_Port, LED6_Pin); break; 

case 7: LL_GPIO_ResetOutputPin(LED7_GPIO_Port, LED7_Pin); break; 

} 

 

// Update position (same as mode 1) 

if (direction) { 

if (currentLED == 7) { 

direction = 0; 

currentLED = 6; // Skip the same LED 

} else { 

currentLED++; 

} 

} else { 

if (currentLED == 0) { 

direction = 1; 

currentLED = 1; // Skip the same LED 

} else { 

currentLED--; 

} 

} 

break; 

 

case 3: // Mode 3: Sparkle mode 

{ 

static uint8_t sparkleState = 0; // 0 = new pattern, 1 = turning off 

static uint8_t ledMask = 0; // Current LED pattern 

static uint8_t ledsRemaining = 0; // Number of LEDs still ON 

 

if (sparkleState == 0) { 

// STEP 1: Pick a random LED pattern (at least one LED on) 

do { 

ledMask = (uint8_t)(HAL_GetTick() * 37u + rand()) & 0xFF; 

} while (ledMask == 0); 

 

// Light LEDs according to pattern 

for (int i = 0; i < 8; i++) { 

if (ledMask & (1 << i)) { 

switch(i) { 

case 0: LL_GPIO_SetOutputPin(LED0_GPIO_Port, LED0_Pin); break; 

case 1: LL_GPIO_SetOutputPin(LED1_GPIO_Port, LED1_Pin); break; 

case 2: LL_GPIO_SetOutputPin(LED2_GPIO_Port, LED2_Pin); break; 

case 3: LL_GPIO_SetOutputPin(LED3_GPIO_Port, LED3_Pin); break; 

case 4: LL_GPIO_SetOutputPin(LED4_GPIO_Port, LED4_Pin); break; 

case 5: LL_GPIO_SetOutputPin(LED5_GPIO_Port, LED5_Pin); break; 

case 6: LL_GPIO_SetOutputPin(LED6_GPIO_Port, LED6_Pin); break; 

case 7: LL_GPIO_SetOutputPin(LED7_GPIO_Port, LED7_Pin); break; 

} 

} else { 

switch(i) { 

case 0: LL_GPIO_ResetOutputPin(LED0_GPIO_Port, LED0_Pin); break; 

case 1: LL_GPIO_ResetOutputPin(LED1_GPIO_Port, LED1_Pin); break; 

case 2: LL_GPIO_ResetOutputPin(LED2_GPIO_Port, LED2_Pin); break; 

case 3: LL_GPIO_ResetOutputPin(LED3_GPIO_Port, LED3_Pin); break; 

case 4: LL_GPIO_ResetOutputPin(LED4_GPIO_Port, LED4_Pin); break; 

case 5: LL_GPIO_ResetOutputPin(LED5_GPIO_Port, LED5_Pin); break; 

case 6: LL_GPIO_ResetOutputPin(LED6_GPIO_Port, LED6_Pin); break; 

case 7: LL_GPIO_ResetOutputPin(LED7_GPIO_Port, LED7_Pin); break; 

} 

} 

} 

 

ledsRemaining = __builtin_popcount(ledMask); 

 

// Wait 100–1500 ms before starting to turn off LEDs 

sparkleDelay = 100 + (HAL_GetTick() % 1401); 

sparkleCounter = 0; 

sparkleState = 1; 

return; // Wait until next interrupt(s) to progress 

} 

else if (sparkleState == 1) { 

// STEP 2: Delay before turning off next LED 

sparkleCounter += __HAL_TIM_GET_AUTORELOAD(&htim16) + 1; 

if (sparkleCounter < sparkleDelay) return; 

 

sparkleCounter = 0; 

sparkleDelay = 50 + (HAL_GetTick() % 100); // 50–150 ms between offs 

 

// Randomly pick one ON LED and turn it off 

uint8_t onIndices[8]; 

uint8_t idxCount = 0; 

for (uint8_t i = 0; i < 8; i++) { 

if (ledMask & (1 << i)) { 

onIndices[idxCount++] = i; 

} 

} 

if (idxCount > 0) { 

uint8_t chosen = onIndices[HAL_GetTick() % idxCount]; 

ledMask &= ~(1 << chosen); 

switch(chosen) { 

case 0: LL_GPIO_ResetOutputPin(LED0_GPIO_Port, LED0_Pin); break; 

case 1: LL_GPIO_ResetOutputPin(LED1_GPIO_Port, LED1_Pin); break; 

case 2: LL_GPIO_ResetOutputPin(LED2_GPIO_Port, LED2_Pin); break; 

case 3: LL_GPIO_ResetOutputPin(LED3_GPIO_Port, LED3_Pin); break; 

case 4: LL_GPIO_ResetOutputPin(LED4_GPIO_Port, LED4_Pin); break; 

case 5: LL_GPIO_ResetOutputPin(LED5_GPIO_Port, LED5_Pin); break; 

case 6: LL_GPIO_ResetOutputPin(LED6_GPIO_Port, LED6_Pin); break; 

case 7: LL_GPIO_ResetOutputPin(LED7_GPIO_Port, LED7_Pin); break; 

} 

ledsRemaining--; 

} 

 

// If no LEDs left, go back to new pattern 

if (ledsRemaining == 0) { 

sparkleState = 0; 

} 

} 

} 

break; 

 

} 

} 

/* USER CODE END 4 */ 

 

/** 

* @brief This function is executed in case of error occurrence. 

* @retval None 

*/ 

void Error_Handler(void) 

{ 

/* USER CODE BEGIN Error_Handler_Debug */ 

/* User can add his own implementation to report the HAL error return state */ 

__disable_irq(); 

while (1) 

{ 

} 

/* USER CODE END Error_Handler_Debug */ 

} 

 

#ifdef USE_FULL_ASSERT 

/** 

* @brief Reports the name of the source file and the source line number 

* where the assert_param error has occurred. 

* @param file: pointer to the source file name 

* @param line: assert_param error line source number 

* @retval None 

*/ 

void assert_failed(uint8_t *file, uint32_t line) 

{ 

/* USER CODE BEGIN 6 */ 

/* User can add his own implementation to report the file name and line number, 

ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */ 

/* USER CODE END 6 */ 

} 

#endif /* USE_FULL_ASSERT */ 

 
